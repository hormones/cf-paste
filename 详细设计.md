# 项目重构详细设计（轻量化方案）

## 📋 设计概述

本重构**只解决核心问题**，避免过度设计：
1. **常量重复**：根目录共享constants.ts
2. **上传重复代码**：两个函数统一上传逻辑  
3. **组件职责过重**：轻量级拆分DefaultTemplate.vue

**原则：轻量 + 简洁 + 优雅，必要时放弃设计**

---

## 🏗️ 第一阶段：基础优化

### 1. 🔄 共享常量（保持简单）

#### 实施方案
```typescript
// constants.ts (项目根目录)
export const EXPIRY_OPTIONS = [
  { label: '1小时', value: 60 * 60 },
  { label: '1天', value: 24 * 60 * 60 },
  { label: '3天', value: 3 * 24 * 60 * 60 },
  { label: '1周', value: 7 * 24 * 60 * 60 },
  { label: '1个月', value: 30 * 24 * 60 * 60 },
  { label: '3个月', value: 90 * 24 * 60 * 60 },
] as const

export const STORAGE_CONSTANTS = {
  PASTE_FILE: 'index.txt',
  FILE_FOLDER: 'files',
  TEMPLATE_FOLDER: 'templates',
} as const

export const RESERVED_WORDS = [
  'index', 'main', 'config', 'utils', 'views', 'public',
  'pages', 'admin', 'template', 'templates', 'file', 'files',
] as const

// 向后兼容的统一导出
export const Constant = {
  WORD: 'word',
  AUTH: 'auth',
  PASSWORD_DISPLAY: '******',
  ...STORAGE_CONSTANTS,
  REVERSED_WORDS: RESERVED_WORDS,
  EXPIRY_OPTIONS,
  MESSAGES: {
    NO_CONTENT: '请输入内容或上传文件',
    SAVE_SUCCESS: '保存成功',
    UPLOAD_SUCCESS: '上传成功',
    // 其他消息...
  }
} as const
```

```typescript
// src/constant/index.ts 
export { Constant, EXPIRY_OPTIONS } from '../../constants'

// server/constant/index.ts
export { Constant, EXPIRY_OPTIONS } from '../../constants'
// 后端验证: const allowedValues = EXPIRY_OPTIONS.map(opt => opt.value)
```

### 2. 轻量错误处理

```typescript
// src/utils/errorHandler.ts - 一个函数搞定
export function handleError(error: any): string {
  if (!error.response) return '网络连接失败'
  
  const status = error.response.status
  if (status === 401 || status === 403) return '访问被拒绝'
  if (status === 413) return '文件太大'
  if (error.name === 'AbortError') return '操作已取消'
  
  return error.response?.data?.msg || error.message || '操作失败'
}
```

---

## 🔧 第二阶段：核心优化  

### 3. 🔴 上传架构极简化

#### 删除的复杂设计
- ❌ FileUploader类 (100+行)
- ❌ ProgressTracker类 (80+行) 
- ❌ 复杂的回调接口
- ❌ 并发控制逻辑

#### ✅ 新设计：两个函数解决一切

```typescript
// src/utils/fileUploader.ts - 极简设计
let configCache: UploadConfig | null = null

/**
 * 主上传函数 - 自动选择策略
 */
export async function uploadFile(
  file: File,
  onProgress?: (percentage: number) => void
): Promise<void> {
  const config = await getConfig()
  
  if (file.size > config.chunkThreshold) {
    return uploadChunked(file, config, onProgress)
  } else {
    return uploadDirect(file, onProgress)
  }
}

/**
 * 直传上传
 */
async function uploadDirect(file: File, onProgress?: (percentage: number) => void) {
  return new Promise<void>((resolve, reject) => {
    const xhr = new XMLHttpRequest()
    
    xhr.upload.onprogress = (e) => {
      if (e.lengthComputable && onProgress) {
        onProgress(Math.round((e.loaded / e.total) * 100))
      }
    }
    
    xhr.onload = () => xhr.status === 200 ? resolve() : reject(new Error(`上传失败: ${xhr.status}`))
    xhr.onerror = () => reject(new Error('网络错误'))
    
    xhr.open('POST', `/api/file/${file.name}`)
    xhr.setRequestHeader('Content-Type', 'application/octet-stream')
    xhr.send(file)
  })
}

/**
 * 分片上传 - 顺序简单
 */
async function uploadChunked(file: File, config: UploadConfig, onProgress?: (percentage: number) => void) {
  // 1. 初始化
  const { data: init } = await request.post('/file/multipart/init', {
    filename: file.name,
    fileSize: file.size,
    chunkSize: config.chunkSize
  })
  
  const { uploadId, totalChunks } = init
  const parts: Array<{ partNumber: number; etag: string }> = []
  
  try {
    // 2. 顺序上传（无并发，简化）
    for (let i = 0; i < totalChunks; i++) {
      const start = i * config.chunkSize
      const end = Math.min(start + config.chunkSize, file.size)
      const chunk = file.slice(start, end)
      
      const { data } = await request.put(`/file/multipart/chunk/${uploadId}`, chunk, {
        params: { partNumber: i + 1, fileKey: file.name }
      })
      
      parts.push({ partNumber: i + 1, etag: data.etag })
      onProgress?.(Math.round(((i + 1) / totalChunks) * 100))
    }
    
    // 3. 完成
    await request.post(`/file/multipart/complete/${uploadId}`, {
      fileKey: file.name,
      parts
    })
  } catch (error) {
    // 清理
    try {
      await request.delete(`/file/multipart/cancel/${uploadId}`)
    } catch {}
    throw error
  }
}

async function getConfig(): Promise<UploadConfig> {
  if (!configCache) {
    try {
      configCache = await configApi.getUploadConfig()
    } catch {
      configCache = { // 默认配置
        maxFileSize: 300 * 1024 * 1024,
        chunkThreshold: 100 * 1024 * 1024,
        chunkSize: 50 * 1024 * 1024,
        maxFiles: 10,
        maxTotalSize: 300 * 1024 * 1024,
        maxConcurrent: 3
      }
    }
  }
  return configCache
}
```

### 4. API层轻量简化

```typescript
// src/api/file.ts - 删除重复方法，保留核心
export const fileApi = {
  // 只保留必要的方法
  async upload(file: File, onProgress?: (percentage: number) => void) {
    try {
      await uploadFile(file, onProgress)
      return { success: true }
    } catch (error) {
      throw new Error(handleError(error))
    }
  },
  
  async list() {
    return request.get('/file/list')
  },
  
  async delete(filename: string) {
    return request.delete(`/file/${filename}`)
  },
  
  download(filename: string) {
    window.open(`/api/file/download?name=${filename}`)
  }
}
```

### 5. 状态管理轻量化

```typescript
// src/composables/useUploadConfig.ts - 去掉provide/inject
const config = ref<UploadConfig | null>(null)

export function useUploadConfig() {
  const fetchConfig = async () => {
    if (!config.value) {
      config.value = await getConfig()
    }
    return config.value
  }
  
  return { config: readonly(config), fetchConfig }
}
```

---

## 🎨 第三阶段：组件优化（充分拆分 + Element组件化）

### 6. 组件拆分方案

#### 🎯 拆分目标
- **职责单一**：每个组件只负责一个功能区域
- **样式优化**：大量使用Element Plus组件，减少自定义CSS
- **易维护**：逻辑清晰，便于后续扩展

#### 📦 组件拆分清单

```vue
<!-- src/templates/DefaultTemplate.vue - 轻量化主容器 -->
<template>
  <div class="paste-container">
    <el-row :gutter="20" class="main-layout">
      <el-col :span="viewMode ? 24 : 16">
        <TabsContainer 
          v-model:active-tab="activeTab"
          :view-mode="viewMode"
          @delete="handleDelete"
          @open-settings="handleOpenSettings"
        >
          <template #clipboard>
            <ClipboardPanel 
              v-model="keyword.content"
              :view-mode="viewMode"
              @auto-save="autoSave"
            />
          </template>
          <template #files>
            <FileUploadPanel 
              :can-upload="canUpload"
              :max-files="maxFiles"
              :max-total-size="maxTotalSize"
              :used-space="usedSpace"
              :upload-states="uploadStates"
              :view-mode="viewMode"
              @upload="handleFileUpload"
              @retry="handleRetry"
              @cancel="cancelUpload"
              @dismiss="handleDismissUpload"
            />
            <FileTable
              :file-list="fileList"
              :view-mode="viewMode"
              :used-space="usedSpace"
              @download="handleFileDownload"
              @delete="handleFileDelete"
              @delete-all="handleDeleteAllFiles"
            />
          </template>
        </TabsContainer>
      </el-col>
      
      <el-col :span="8" v-if="!viewMode">
        <el-space direction="vertical" size="large" fill>
          <InfoPanel :keyword="keyword" />
          <QRCodePanel 
            v-if="keyword.id"
            :keyword="keyword"
            :read-only-link="readOnlyLink"
            @copy-link="copyReadOnlyLink"
          />
        </el-space>
      </el-col>
    </el-row>

    <PasswordDialog v-model="showPasswordDialog" @verified="handlePasswordVerified" />
    <SettingsDialog v-model="showSettings" @save="handleSettingsSave" />
  </div>
</template>
```

#### 🧩 组件详细设计

##### 1. TabsContainer.vue - 标签容器
```vue
<!-- src/components/TabsContainer.vue -->
<template>
  <el-card class="tabs-card" shadow="never">
    <template #header>
      <div class="tabs-header">
        <el-tabs v-model="activeTab" @tab-change="$emit('update:activeTab', $event)">
          <el-tab-pane label="剪贴板" name="clipboard" />
          <el-tab-pane :label="fileTabLabel" name="files" />
        </el-tabs>
        
        <el-space v-if="!viewMode">
          <el-button type="danger" text @click="$emit('delete')" :icon="Delete" />
          <el-button type="primary" text @click="$emit('open-settings')" :icon="Setting" />
        </el-space>
      </div>
    </template>
    
    <div class="tab-content">
      <div v-show="activeTab === 'clipboard'" class="tab-pane">
        <slot name="clipboard" />
      </div>
      <div v-show="activeTab === 'files'" class="tab-pane">
        <slot name="files" />
      </div>
    </div>
  </el-card>
</template>
```

##### 2. ClipboardPanel.vue - 剪贴板面板
```vue
<!-- src/components/ClipboardPanel.vue -->
<template>
  <el-input
    :model-value="modelValue"
    @update:model-value="$emit('update:modelValue', $event)"
    type="textarea"
    :rows="15"
    placeholder="在此输入或粘贴内容..."
    resize="none"
    @blur="$emit('auto-save')"
    :disabled="viewMode"
  />
</template>
```

##### 3. FileUploadPanel.vue - 文件上传面板
```vue
<!-- src/components/FileUploadPanel.vue -->
<template>
  <el-card v-if="uploadStates.size === 0" class="upload-card" shadow="never">
    <el-upload
      :http-request="$emit('upload', $event)"
      :disabled="!canUpload"
      drag
      class="upload-dragger"
    >
      <el-icon class="el-icon--upload"><UploadFilled /></el-icon>
      <div class="el-upload__text">将文件拖到此处，或<em>点击上传</em></div>
      <template #tip>
        <div class="upload-tip">
          <el-text size="small" type="info">
            最多上传 {{ maxFiles }} 个文件，单文件最大 {{ Utils.humanReadableSize(maxTotalSize) }}
          </el-text>
          <el-text v-if="!viewMode" size="small">
            已用空间: {{ Utils.humanReadableSize(usedSpace) }} / {{ Utils.humanReadableSize(maxTotalSize) }}
          </el-text>
        </div>
      </template>
    </el-upload>
  </el-card>
  
  <UploadProgress
    v-else
    :upload-states="uploadStates"
    @retry="$emit('retry', $event)"
    @cancel="$emit('cancel', $event)"
    @dismiss="$emit('dismiss', $event)"
  />
</template>
```

##### 4. FileTable.vue - 文件表格
```vue
<!-- src/components/FileTable.vue -->
<template>
  <div class="file-table-container">
    <el-card v-if="fileList.length > 0 && !viewMode" class="file-actions-card" shadow="never">
      <div class="file-actions">
        <el-text type="info">
          共 {{ fileList.length }} 个文件，{{ Utils.humanReadableSize(usedSpace) }}
        </el-text>
        <el-button type="danger" size="small" :icon="Delete" @click="$emit('delete-all')" plain>
          全部删除
        </el-button>
      </div>
    </el-card>

    <el-table :data="fileList" stripe>
      <el-table-column prop="name" label="文件名" min-width="140" show-overflow-tooltip />
      <el-table-column prop="size" label="大小" min-width="90">
        <template #default="{ row }">
          {{ Utils.humanReadableSize(row.size) }}
        </template>
      </el-table-column>
      <el-table-column prop="uploaded" label="上传时间" min-width="120">
        <template #default="{ row }">
          {{ new Date(row.uploaded).toLocaleString() }}
        </template>
      </el-table-column>
      <el-table-column label="操作" fixed="right" align="center" width="120">
        <template #default="{ row }">
          <el-button-group>
            <el-button type="primary" :icon="Download" @click="$emit('download', row.name)" text />
            <el-button v-if="!viewMode" type="danger" :icon="Delete" @click="$emit('delete', row.name)" text />
          </el-button-group>
        </template>
      </el-table-column>
    </el-table>
  </div>
</template>
```

##### 5. InfoPanel.vue - 信息面板（Element组件化）
```vue
<!-- src/components/InfoPanel.vue -->
<template>
  <el-card class="info-card" shadow="never">
    <template #header>
      <el-text tag="b">基本信息</el-text>
    </template>
    
    <el-descriptions :column="1" border size="small">
      <el-descriptions-item label="创建时间">
        {{ formatDate(keyword.create_time) }}
      </el-descriptions-item>
      <el-descriptions-item label="更新时间">
        {{ formatDate(keyword.update_time) }}
      </el-descriptions-item>
      <el-descriptions-item label="上次查看">
        {{ formatDate(keyword.last_view_time) }}
      </el-descriptions-item>
      <el-descriptions-item label="过期时间">
        {{ formatDate(keyword.expire_time) }}
      </el-descriptions-item>
      <el-descriptions-item label="查看次数">
        {{ !keyword.id ? '-' : (keyword.view_count || 0) + '次' }}
      </el-descriptions-item>
    </el-descriptions>
  </el-card>
</template>
```

##### 6. QRCodePanel.vue - 二维码面板（Element组件化）
```vue
<!-- src/components/QRCodePanel.vue -->
<template>
  <el-card class="qrcode-card" shadow="never">
    <template #header>
      <el-text tag="b">只读链接</el-text>
    </template>
    
    <div class="qrcode-container">
      <div class="qrcode-wrapper" @click="$emit('copy-link')">
        <QRCode :data="readOnlyLink" :size="150" />
        <div class="qrcode-overlay">
          <el-text size="small">点击复制只读链接</el-text>
        </div>
      </div>
      
      <el-divider />
      
      <el-descriptions :column="1" size="small">
        <el-descriptions-item label="口令">
          {{ keyword.view_word }}
        </el-descriptions-item>
      </el-descriptions>
    </div>
  </el-card>
</template>
```

### 7. 样式优化策略

#### 🎨 Element组件替代方案
```scss
// 大幅减少自定义样式，使用Element组件特性

// ✅ 使用 el-card 替代自定义面板
.custom-panel { /* 删除 */ }

// ✅ 使用 el-descriptions 替代自定义info-item
.info-item { /* 删除 */ }

// ✅ 使用 el-space 替代自定义间距
.manual-spacing { /* 删除 */ }

// ✅ 使用 el-divider 替代自定义分割线
.custom-divider { /* 删除 */ }

// ✅ 使用 el-row/el-col 替代自定义布局
.manual-layout { /* 删除 */ }

// ✅ 保留必要的业务样式
.qrcode-overlay {
  position: absolute;
  /* 保留必要的交互样式 */
}
```

---

## ✅ 第四阶段：验证收尾

### 8. 实施步骤

1. **创建** `constants.ts` - 5分钟
2. **更新** 常量引用 - 10分钟  
3. **替换** `src/utils/chunkUploader.ts` - 15分钟
4. **简化** `src/api/file.ts` - 10分钟
5. **测试** 上传功能 - 10分钟
6. **拆分** SettingsDialog - 10分钟（可选）

### 9. 效果预估

- **代码减少**：删除约400行复杂代码
- **文件减少**：删除chunkUploader.ts等
- **复杂度降低**：无类、无复杂接口、无过度抽象
- **维护性提升**：逻辑清晰，容易理解和修改

---

## 💡 最终方案总结

### ✅ 保留的设计
- 共享常量（简单有效）
- 统一上传函数（解决核心问题）
- 轻量错误处理（实用主义）

### ❌ 删除的过度设计  
- 复杂的类和接口系统
- 过度的抽象和封装
- 不必要的组件拆分
- 复杂的状态管理

### 🎯 符合原则
- **轻量**：最少代码解决问题
- **简洁**：逻辑清晰易懂
- **优雅**：必要时放弃设计
- **实用**：快速开发，容易维护

**这是一个真正轻量化的重构方案，符合项目的简洁定位。** 
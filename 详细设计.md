# 通用安全下载方案详细设计 (v2.4)

本文档描述了最终版的安全下载方案，其核心为**"会话级Token与条件滑动过期机制"**。此方案为分享者和浏览者提供了截然不同的下载体验，并在用户体验、安全性和系统性能之间取得了完美平衡。

## 1. 核心思想

我们采用双轨制下载策略，并针对浏览者引入了"下载会话"的概念。

- **分享者 (Owner) 流程 (不变)**:
  - 通过经主密码认证的安全代理端点直接下载，流程简单高效。

- **浏览者 (Viewer) 流程 (核心变更)**:
  - **会话级Token**: 用户只需认证一次`view_word`，即可获得一个**会话Token**。在会话有效期内，此Token可用于下载该分享页面下的**所有文件**。
  - **条件滑动过期 (Conditional Sliding Expiration)**: Token的初始有效期为1小时。只有当Token的剩余有效期**不足30分钟**时，用户的下一次下载行为才会将其有效期**重新延长至1小时**。这极大地减少了不必要的数据库写操作。

此方案依然完整支持HTTP范围请求（Range Requests），保证了原生的断点续传体验。

## 2. D1 数据库设计

`tokens` 表的设计无需任何更改，其通用性完美支持"会话级Token"模型。

### 表名: `tokens`

| 字段名 | 类型 | 约束 | 描述 |
| :--- | :--- | :--- | :--- |
| `id` | `TEXT` | `PRIMARY KEY` | 唯一的会话Token。 |
| `word` | `TEXT` | `NOT NULL` | 会话所属的 `word`。 |
| `view_word` | `TEXT` | `NOT NULL` | 创建会话时所用的 `view_word`。 |
| `ip_address`| `TEXT` | `NOT NULL` | 创建会话的客户端IP地址。 |
| `expires_at`| `INTEGER`| `NOT NULL` | Token的过期时间戳 (Unix epoch, in seconds)。 |

### SQL Schema

```sql
-- 通用授权Token表
CREATE TABLE tokens (
    id TEXT PRIMARY KEY,
    word TEXT NOT NULL,
    view_word TEXT NOT NULL,
    ip_address TEXT NOT NULL,
    expires_at INTEGER NOT NULL
);

CREATE INDEX idx_tokens_expires_at ON tokens (expires_at);
```

## 3. 后端 API 设计

### 3.1. 分享者 (Owner) 下载流程 (API地址简化)

- **API**: `GET /api/file/download/:fileName`
- **逻辑**: 此端点通过认证中间件区分用户身份。
    - **如果是分享者**: 验证主密码 -> 直接代理下载 -> 支持断点续传。
    - **如果是浏览者**: 流程将重定向或引导至第1步（获取会话）。(具体实现由路由逻辑决定)

### 3.2. 浏览者 (Viewer) 下载流程 (已优化)

#### 第1步: `GET /api/file/auth-download` - 创建下载会话 (API地址简化)

- **目的**: 验证`view_word`并创建一个有时效的下载会话。
- **处理流程**:
  1.  验证 `view_word`。
  2.  生成唯一的会话Token `id`。
  3.  获取客户端IP。
  4.  计算 **1小时** 后的初始过期时间 `expires_at`。
  5.  将 `id`, `word`, `view_word`, `ip_address`, `expires_at` 插入 `tokens` 表。
  6.  返回会话Token。

#### 第2步: `GET /api/file/download/:token/:fileName` - 使用会话执行下载

- **目的**: 使用会话Token下载指定文件，并按需刷新会话有效期。
- **处理流程 (针对每个文件的初次点击)**:
  1.  **验证会话**:
      -   查询D1中的 `token`，验证其是否存在、是否过期、IP是否匹配。
  2.  **实时验证 `view_word`**:
      -   使用 `token` 记录中的 `word` 去 `keyword` 表中查询**当前最新**的 `view_word`。
      -   将查询到的 `view_word` 与Token记录中的 `view_word` 对比。
      -   **若不匹配，则会话失效**，立即返回 `403 Forbidden`，中断后续所有下载。
  3.  **[最终优化] 条件刷新会话有效期**:
      -   所有验证通过后，检查Token的剩余时间：`remaining_time = expires_at - now`。
      -   **仅当 `remaining_time < 30 * 60` (剩余时间不足30分钟) 时**，才执行数据库更新操作：
          ```sql
          UPDATE tokens SET expires_at = <now + 1 hour> WHERE id = :token;
          ```
      -   否则，不执行任何数据库写操作。
  4.  **代理下载**:
      -   使用 `token` 记录中的 `word` 和URL中的 `fileName` 构建 `r2_key`。
      -   从R2获取文件对象，处理 `Range` 请求，将文件流返回给浏览器。

## 4. 前端实现调整

前端逻辑将变得更流畅：
1.  **进入浏览模式后**:
    -   立即调用 `fileApi.getDownloadAuth()` 获取一个**会话Token**。
    -   将此Token存储在前端状态中（如Pinia或组件`ref`）。
2.  **点击下载按钮时**:
    -   **分享者模式**: 直接构造 `/api/file/download/:fileName` 链接。
    -   **浏览者模式**: 使用已存储的会话Token，构造 `/api/file/download/:token/:fileName` 链接。
3.  **会话失效处理**:
    -   如果下载请求返回403错误，意味着会话已失效。前端应清除本地存储的Token，并引导用户重新输入`view_word`以创建新会话。

## 5. 定期清理任务 (明确现有任务)

- **任务**: 现有每日0点运行的定时清理任务需要被更新。
- **要求**: 确保该任务的逻辑中，包含对 `tokens` 表的清理操作。
- **Worker逻辑**: `DELETE FROM tokens WHERE expires_at <= strftime('%s', 'now');`

## 6. 方案权衡与总结

最终方案 (v2.4) 是一个高度优化的模型：
-   **最佳用户体验**: 用户只需验证一次，即可在1小时的活跃期内自由下载所有文件，操作连贯。
-   **更强的安全性**: "滑动过期"机制将Token的暴露窗口从固定的24小时缩短为"最后一次活动后的1小时"，大大降低了Token泄露的风险。
-   **即时撤销能力**: 保留了对`view_word`的实时校验，确保了管理员控制权的即时性。
-   **性能权衡**: 唯一的代价是在每次下载时增加了一次数据库`UPDATE`操作。对于D1这种高性能的无服务器数据库，这种开销是完全可以接受的，用以换取安全性和用户体验的巨大提升是值得的。 